use crate::types::error::Error;
use crate::types::types::LogTree;
use crate::zeek::zeek_log_proto::ZeekProtocol;

use crate::zeek::zeek_log::ZeekLog;
use crate::zeek::zeek_search_params::ZeekSearchParams;

use std::path::Path;
use std::collections::HashMap;
use std::collections::btree_map::BTreeMap;


#[derive(Debug, PartialEq, Eq)]
pub struct
ZeekLogDirectory
{
    // default log path: /usr/local/zeek or /opt/zeek or custom/path/
    // https://docs.zeek.org/en/master/quickstart.html#filesystem-walkthrough
    //path_prefix: Option<&'a str>,
    pub data: LogTree,
}
impl ZeekLogDirectory
{
    // Initializes structure to search through logs using the path_prefix/ as the
    // parent log directory.
    //pub fn new(p: Option<&'a Path>) -> Self //Result<Self, Error>
    pub fn new() -> Self
    {
        ZeekLogDirectory {
            data: BTreeMap::new()
        }
        /*
        match p 
        {
            None => {
                // check whether the default paths exist
                //let opt_zeek = std::path::Path::new("/opt/zeek/");
                //let usr_local_zeek = std::path::Path::new("/usr/local/zeek/");
                if opt_zeek.is_dir() 
                {
                    return Ok(ZeekLogDirectory {
                        path_prefix: opt_zeek.to_str(),
                        data: BTreeMap::new(),
                    })
                } 
                if usr_local_zeek.is_dir() 
                {
                    return Ok(ZeekLogDirectory {
                        path_prefix: usr_local_zeek.to_str(),
                        data: BTreeMap::new(),
                    })
                } 
                return Err(Error::PathPrefixUnspecified)
            }
            Some(path) => {
                let parent_log_dir = std::path::Path::new(path);
                if parent_log_dir.is_dir() 
                {
                    return Ok(ZeekLogDirectory {
                        path_prefix: path.to_str(),
                        data: BTreeMap::new(),
                    })
                }
                return Err(Error::PathNotFound)
            }
        }
        */
    }

    pub fn read(&self, p : &std::path::Path, map: &mut HashMap::<String, Vec::<String>>)
        -> Result<(), Error>
    {
        let output = std::process::Command::new("zcat")
            .arg(&p)
            .output()
            .expect("failed to zcat the log file");
        let log_header = output.stdout;

        let mut _separator : char = ' ';
        let mut fields = Vec::<String>::new(); 

        match std::str::from_utf8(&log_header) 
        {
            Ok(v) => {
                // Load the header.
                let line: Vec<&str> = v.split('\n').collect();
                let result = line[0].split(' ')
                                .collect::<Vec<&str>>()[1]
                                .strip_prefix("\\x");

                // File does not have header info.
                // This should not return an error due to the calling function's 
                // check. Leaving here until something useful is needed from the 
                // logs without a header.
                if result == None { 
                    return Err(Error::NoLogHeader) 
                } 

                let result = u8::from_str_radix(result.unwrap().trim(), 16)
                    .expect("Should have a separator character in the log file."); 

                _separator = char::from(result);

                let s = line[6].split(_separator).collect::<Vec<_>>();

                for i in 1..s.len() 
                {
                    fields.push(s[i].to_string());
                }

                let mut data = Vec::<String>::new();
                for f in fields.iter()
                {
                    map.insert(f.to_string(), Vec::<String>::new());
                    data.push(f.to_string());
                }

                // Should never fail.
                assert_eq!(data.len(), fields.len());

                // Load the data 
                for n in 8..line.len() // line.len() - 2 == #close\tdate which is not used.
                {
                    let items = line[n].split(_separator).collect::<Vec<_>>();
                    if items[0] == "#close" {break;}
                    for item in 0..items.len() - 1
                    {
                        if let Some(m) = map.get_mut(&data[item])
                        {
                            m.push(items[item].to_string());
                        }
                    }
                }
            }
            Err(_) => {
                return  Err(Error::Unspecified) 
            }
        }
        Ok(())
    }
    /*
    fn path_prefix_exists(&self) -> bool 
    {
        match &self.path_prefix 
        {
            Some(_) => { return true }
            None => { return false}
        }
    }
    */

    pub fn search(&mut self, params: &ZeekSearchParams) -> Result<LogTree, Error> 
    {
        let search : u8 = params.check();

        /////////////////////////////////////////////////////////////
        // Somehow, this needs to be available at compile time.
        // For now, just set it to 8 for the bits and accept that the
        // msb will be zero.
        //let param_count = params.get_param_count(); 

        // spawn a thread for each param and arc 
        let mut bits = [0; 8];
        for i in 0..8 
        {
            bits[7 - i] = (search >> i) & 1;
            dbg!(bits[i]);
        }
        ///////////////////////////////////

        if search == 0 
        {
            return Err(Error::SearchInsufficientParams)
        } 

        /////////////////////////////////////////////////////
        // moved to params
        /*

        let mut search_path = String::new();

        if Self::path_prefix_exists(self) 
        {
            search_path.push_str(&self.path_prefix.unwrap());
            search_path.push_str("/");
            search_path.push_str(params.start_date.unwrap());
            search_path.push_str("/");
        } 
        else 
        {
            search_path.push_str(params.start_date.unwrap());
            search_path.push_str("/");
        }
        */

        match search 
        {
            1 => {
                dbg!(&params);
                return Err(Error::SearchInvalidStartDate)
                //let path = Path::new(search_path.as_str());     
            }
            9 => {}
            _ => return Err(Error::SearchInvalidStartDate)
        }

        //let path = Path::new(search_path.as_str());     

        Err(Error::SearchInvalidStartDate)
          
        /*
        match path.is_dir()
        {
            true => {
                match search
                {
                    // search start date for all
                    1 => { 
                        for entry in std::fs::read_dir(&path).expect("error reading path") 
                        {
                            let log = entry.unwrap();
                            let p = log.path();
                            let p = p.to_str().expect("The path to log file should exist.");
                            let p = p.split('/').collect::<Vec<_>>();
                            let p = p[p.len()-1].split('.').collect::<Vec<_>>();

                            //////////////////////////////////////////////////////
                            // NOTE: p[0] = proto, p[1] = time, p[2..] = filetype
                            //////////////////////////////////////////////////////
                            let proto = ZeekProtocol::read(p[0]);

                            if !self.data.contains_key(&proto) && !(proto == ZeekProtocol::NONE)
                            {
                                // To handle post processing easier, convert the inner
                                // vector to a hashmap and return it. 
                                let mut hp = HashMap::<String, HashMap<String, Vec<String>>>::new();
                                hp.insert(p[1].to_string(), HashMap::<String, Vec::<String>>::new());
                                self.data.insert(proto.clone(), hp);
                            }

                            // Create time range (e.g. 00-01) and use as keys to BTreeMap.
                            if let Some(value) = self.data.get_mut(&proto) 
                            {
                                value.insert(p[1].to_string(), HashMap::<String, Vec::<String>>::new());
                            }

                            // Only pass the vector corresponding to the time.
                            if let Some(t) = self.data.get_mut(&proto) 
                            {
                                if let Some(g) = t.get_mut(&p[1].to_string())
                                {
                                    // thread here?
                                    let _ = ZeekLogData::read(log.path().as_path(), g);
                                }
                            }
                        }
                    }
                    // search start date and ip
                    //5 => {
                    //    for entry in std::fs::read_dir(&path).expect("path to log dir should exist.")
                    //    {
                    //        
                    //    }
                    //}
                    _ => {
                        //dbg!(search);
                        return Ok(self.data.clone())
                    }
                }
                return Ok(self.data.clone())
            }
            false => {
                return Err(Error::SearchInvalidStartDate)
            }
        }
        */
    }
}

